#!/usr/bin/env bash

set -x

# Reduce dirty bytes for USB devices, to make it write more directly to storage, instead to cache

block_device="${1}"
vendor_id="${2}"
model_id="${3}"

# Determine current USB device speed, as ATTRS{speed} is unreliable - it detects xHCI USB speed instead of proper USB speed
current_usb_speed=$(lshw -json -class storage -numeric | jq -r ".[] | select(.id | contains(\"usb\")) | select(.product | endswith(\"[${vendor_id}:${model_id}]\")) | .configuration.speed | gsub(\"[^0-9.]\";\"\")")

# If current USB speed is somehow not determined or wrongly parsed, then stop the script
if [[ -z "${current_usb_speed}" ]] || [[ "${current_usb_speed}" == "null" ]]; then
  echo "Cannot determine current USB speed for the device to write custom max_bytes dirty value"
  echo "Exiting"
  exit 1
fi

# apply strict limit to dirty bytes
strict_limit=1
max_ratio=50
echo "${strict_limit}" > "/sys/block/${block_device}/bdi/strict_limit"
echo "${max_ratio}" > "/sys/block/${block_device}/bdi/max_ratio"

buffer_time="0.05"
safety_factor="1.3"
max_bytes_calculation=$(echo "((${current_usb_speed} / 8) * ${buffer_time} * ${safety_factor}) * 1024 * 1024" | bc)
max_bytes=$(echo "${max_bytes_calculation}" | awk '{print ($1 - int($1) > 0.5) ? int($1) + 1 : int($1)}')

# apply bandwidth defined value
echo "${max_bytes}" > "/sys/block/${block_device}/bdi/max_bytes"
